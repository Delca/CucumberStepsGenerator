package generator;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StepsGenerator {

    private static final String STEP_METHOD_TEMPLATE = "\t@:STEP_CATEGORY(:STEP_GENERATED)\n\tpublic void :STEP_METHOD_NAME(:STEP_METHOD_ARGS) throws Throwable {\n\n\t}\n\n";

    private static final String INDENT = "    ";

    /**
     * When set to true, "And" and "But" steps will be annotated according to where they are placed in the
     * scenario (Given, When or Then).
     */
    private static boolean revealAdditionalSteps = false;

    /**
     * When set to true, method names will be written in camel case notation.
     * When set to false, method names will be written in lowercase with underscores separating words
     */
    private static boolean useCamelCase = false;

    /**
     * When set to true, the method name will be generated by prefixing the step category to
     * the step text.
     */
    private static boolean startMethodNameWithStepCategory = false;

    public static String addStepsFromFeatureFile(String featurePath, String stepPath, String... otherStepPaths) {
        // We start by retrieving the two relevant files as Strings
        String featureAsString = FileToolBox.readFile(featurePath);
        String stepAsString = FileToolBox.readFile(stepPath);

        Set<String> stepsFilePaths = new HashSet<String>();
        stepsFilePaths.add(stepPath);
        for (String path : otherStepPaths) {
            stepsFilePaths.add(path);
        }

        // We get the already implemented steps. Note that since we are working on the file
        // from a String, we do not parse Java to see if there is actually a method ; we rely
        // on finding the annotation alone
        Set<String> alreadyImplementedSteps = StepsFileToolBox.getAlreadyImplementedSteps(stepsFilePaths.toArray(new String[0]));
        // Next, we generate a method for each steps found in the feature file
        Map<String, String> stepMethodByStep = FeatureFileToolBox.getStepsMethodsFromFeatureFile(featureAsString);
        // To append to the class in such a way that it remains compilable, we remove
        // the closing curly bracket of the class
        String newStepsFile = StepsFileToolBox.prepareStringForAppend(stepAsString);

        // Then, for each generated method, we try to see if there is not already an implementation
        // in the target steps file
        for (Entry<String, String> entry : stepMethodByStep.entrySet()) {
            if (!alreadyImplementedSteps.contains(entry.getKey())) {
                newStepsFile = newStepsFile.concat(entry.getValue());
                // Do not forget to add it to the list of implemented steps, else doubles may appear
                alreadyImplementedSteps.add(entry.getKey());
            }
        }

        // We replace the curly bracket we removed earlier
        newStepsFile = StepsFileToolBox.addClosingCurlyBracket(newStepsFile);

        return newStepsFile;
    }

    public static Set<String> getMissingSteps(String featurePath, String stepPath, String... otherStepPaths) {
        // This function greatly ressembles the method-implementing one, except that
        // instead of actually implementing the methods, we simply collect the steps
        // that they would implement
        String featureAsString = FileToolBox.readFile(featurePath);

        Set<String> stepsFilePaths = new HashSet<String>();
        stepsFilePaths.add(stepPath);
        for (String path : otherStepPaths) {
            stepsFilePaths.add(path);
        }

        Set<String> missingSteps = new LinkedHashSet<String>();
        Set<String> alreadyPresentSteps = StepsFileToolBox.getAlreadyImplementedSteps(stepsFilePaths.toArray(new String[0]));
        Map<String, String> stepMethodByStep = FeatureFileToolBox.getStepsMethodsFromFeatureFile(featureAsString);

        for (Entry<String, String> entry : stepMethodByStep.entrySet()) {
            if (!alreadyPresentSteps.contains(entry.getKey())) {
                missingSteps.add(entry.getKey());
            }
        }
        return missingSteps;
    }

    public static boolean isRevealAdditionalSteps() {
        return revealAdditionalSteps;
    }

    public static void setRevealAdditionalSteps(boolean revealAdditionalSteps) {
        StepsGenerator.revealAdditionalSteps = revealAdditionalSteps;
    }

    private static final class FeatureFileToolBox {

        public static Map<String, String> getStepsMethodsFromFeatureFile(String fileAsString) {
            // A LinkedHashMap is used here to preserve the insertion order, useful to display
            // the steps that will be implemented in the same order that they are written in
            // in the file
            Map<String, String> stepsMethodsBySteps = new LinkedHashMap<String, String>();

            String[] lines = fileAsString.split("\n");
            String lastParsedStepCategory = "";

            for (String line : lines) {

                line = removeSharpComment(line);

                // Ignoring the leading whitespaces / tabulations allows to process
                // indented feature files
                while (line.length() > 0 && (line.charAt(0) == ' ' || line.charAt(0) == '\t')) {
                    line = line.substring(1);
                }

                // If a feature is formatted as a step
                if (isAFeatureStep(line)) {
                    // Then he first word is the category (GIVEN/WHEN/THEN)
                    String stepCategory = line.split(" ")[0];

                    // Special code to treat the 'And' and 'But' steps differently
                    if ((!stepCategory.equals("And") || !stepCategory.equals("But")) || (isRevealAdditionalSteps())){
                        lastParsedStepCategory = stepCategory;
                    }

                    // Generate the annotated method from the step ...
                    String stepMethod = generateStepMethodFromStep(line, lastParsedStepCategory);

                    // ... and add it to the map of generated methods
                    stepsMethodsBySteps.put(StepsFileToolBox.getStepAsString(stepMethod), stepMethod);
                }
            }

            return stepsMethodsBySteps;
        }

        private static boolean isAFeatureStep(String line) {
            // TODO: maybe support different languages ?
            return line.matches("[ \t]*(Given|When|Then|And|But) ..*");
        }

        private static String[] separateIntoTokens(String step) {
            // Basically, each token is a chain of characters delimited by a ' ' character
            // However, we treat anything between double quotes (") as a single token
            // That is because anything between double quotes will be a parameter and
            // thus need to be processed accordingly
            StringBuilder builder = new StringBuilder();
            List<String> tokens = new ArrayList<String>();
            char[] characters = step.toCharArray();
            boolean isParsingString = false;

            for (char c : characters) {
                switch (c) {
                    case '"':
                        builder.append(c);
                        // We have a very basic state automata
                        // That means no nested quotes ...
                        isParsingString = !isParsingString;
                        break;
                    case ' ':
                        // If we inside a double quote, we treat the ' ' character as any other one
                        if (isParsingString) {
                            builder.append(c);
                        }
                        // Else, it marks the limit between two tokens
                        else {
                            tokens.add(builder.toString());
                            builder = new StringBuilder();
                        }
                        break;
                    default:
                        builder.append(c);
                        break;
                }

            }

            // Do not forget to add the last parsed token, otherwise it
            // will not be added if the line does not end with a whitespace
            if (builder.length() > 0) {
                tokens.add(builder.toString());
            }

            return tokens.toArray(new String[0]);
        }

        public static String removeForbiddenCharacters(String step) {
            return step.replaceAll("[^0-9a-zA-Z]", "");
        }

        private static String capitalizeWord(String currentWord) {
            String result = null;
            if (currentWord != null) {
                if (currentWord.length() > 1) {
                    result = currentWord.substring(0, 1).toUpperCase().concat(currentWord.substring(1));
                }
                else {
                    result = currentWord.toUpperCase();
                }
            }

            return result;
        }

        private static String uncapitalizeWord(String currentWord) {
            String result = null;
            if (currentWord != null) {
                if (currentWord.length() > 1) {
                    result = currentWord.substring(0, 1).toLowerCase().concat(currentWord.substring(1));
                }
                else {
                    result = currentWord.toLowerCase();
                }
            }

            return result;
        }

        private static boolean isAString(String currentWord) {
            // This part of the code makes the assumption that each parametered
            // input is a String. As there is no way of knowing whether this
            // input will or will not be a number (other than parsing its table,
            // which would be quite a pain), this is the best way of dealing with
            // the problem
            return currentWord.matches("\".*\"") || currentWord.matches("<.*>");
        }

        private static boolean isANumber(String currentWord) {
            return currentWord.matches("[0-9][0-9]*");
        }

        public static String generateStepMethodFromStep(String step, String lastParsedStepCategory) {
            String method = null;
            String generatedStep = "";

            // First things first, we separate the step into tokens
            String[] words = separateIntoTokens(step);

            String stepCategory = words[0];
            String stepCategoryForAnnotation = stepCategory;
            // The lastParsedStepCategory will be set by the calling method according to the value of
            // the global boolean revealAdditionalSteps.
            if (stepCategoryForAnnotation.equals("And")
                    || stepCategoryForAnnotation.equals("But")) {
                stepCategoryForAnnotation = lastParsedStepCategory;
            }
            String methodName = "";
            String methodArgs = "";
            int argNums = 0;

            // We iterates over the tokens composing the step
            for (int i = 1; i < words.length; ++i) {
                String currentWord = words[i];

                // If the token is a number, we add the corresponding regexp to the generated step which will
                // be the parameter of the annotation and a parameter to the generated method.
                if (isANumber(currentWord)) {
                    generatedStep += "(\\\\d+) ";
                    methodArgs += "long number" + argNums++ + ", ";
                }
                // If the token is a String (delimited by double quotes), we add the corresponding regexp
                // to the generated step and a parameter to the generated method.
                else if (isAString(currentWord)) {
                    generatedStep += "\\\"([^\\\"]+)\\\" ";
                    methodArgs += "String string" + argNums++ + ", ";
                }
                // Else, the token is just another normal word. We can thus just add it to the generated
                // step and, once all non-alphanumeric character are removed, to the generated method's name
                else {
                    generatedStep += currentWord + " ";

                    if (currentWord.trim().length() > 0) {
                        if (isUseCamelCase()) {
                            // Capitalizing the word is a way of conserving the camel case notation
                            methodName += capitalizeWord(removeForbiddenCharacters(currentWord));
                        }
                        else {
                            methodName += "_" + removeForbiddenCharacters(currentWord).toLowerCase();
                        }
                    }

                }

            }

            if (isStartMethodNameWithStepCategory()) {
                // As the step category is the leading word in the method's name, it will always be in lower case
                methodName = stepCategory.toLowerCase() + methodName;
            }
            else {
                if (!isUseCamelCase()) {
                    // We need to remove the leading underscore, which does not make sense
                    methodName = methodName.substring(1);
                }

                // Since words are added in capitalized form, we must uncapitalize the first one
                methodName = uncapitalizeWord(methodName);
            }

            // When adding a parameter, we blindly add a comma and a space after it. That is why
            // we need to remove the last two characters in that field if there is at least one parameter
            if (methodArgs.length() > 0) {
                methodArgs = methodArgs.substring(0, methodArgs.length() - 2);
            }

            // The generated step should always match an entire line
            generatedStep = "\"^" + generatedStep.trim() + "$\"";

            // Here, we use the method template and replace all the important parts with
            // the ones generated above
            method = STEP_METHOD_TEMPLATE
                     .replace("\t", INDENT)
                     .replace(":STEP_CATEGORY", capitalizeWord(stepCategoryForAnnotation))
                     .replace(":STEP_GENERATED", generatedStep)
                     .replace(":STEP_METHOD_NAME", methodName)
                     .replace(":STEP_METHOD_ARGS", methodArgs)
                     ;

            return method;
        }

        private static String removeSharpComment(String line) {
            String result = "";
            final Pattern PRODUCT_URL_PATTERN = Pattern.compile("(([^#\"]|\".*\")*)(#.*)?");

            Matcher m = PRODUCT_URL_PATTERN.matcher(line);
            if (m.find()) {
                result = m.group(1);
            }

            return result;
        }

    }

    public static boolean isUseCamelCase() {
        return useCamelCase;
    }

    public static void setUseCamelCase(boolean useCamelCase) {
        StepsGenerator.useCamelCase = useCamelCase;
    }

    public static boolean isStartMethodNameWithStepCategory() {
        return startMethodNameWithStepCategory;
    }

    public static void setStartMethodNameWithStepCategory(boolean startMethodNameWithStepCategory) {
        StepsGenerator.startMethodNameWithStepCategory = startMethodNameWithStepCategory;
    }

    private static final class StepsFileToolBox {

        public static Set<String> getAlreadyImplementedSteps(String... filePaths) {
            Set<String> alreadyImplementedSteps = new LinkedHashSet<String>();

            for (String filePath : filePaths) {
                String stepsFileAsString = FileToolBox.readFile(filePath);
                alreadyImplementedSteps.addAll(getAlreadyImplementedStepsFromFile(stepsFileAsString));
            }

            return alreadyImplementedSteps;
        }

        public static Set<String> getAlreadyImplementedStepsFromFile(String fileAsString) {
            // Here, we parse the steps file to get every step that is present in an annotation
            Set<String> alreadyPresentsSteps = new HashSet<String>();
            String[] lines = fileAsString.split("\n");

            for (String line : lines) {
                // This method will return null if the line does not contain a step annotation with a step
                String step = getStepAsString(line);

                if (step != null) {
                    // We will be comparing those parsed steps with generated ones, which will always match
                    // an entire line. As we are merciful, we allow the users to NOT respect this convention
                    // and still use our tool as intended.
                    if (step.charAt(0) != '^') {
                        step = "^" + step;
                    }
                    if (step.charAt(step.length() - 1) != '$') {
                        step = step.concat("$");
                    }

                    alreadyPresentsSteps.add(step);
                }
            }

            return alreadyPresentsSteps;
        }

        public static String getStepAsString(String line) {
            String result = null;
            // TODO: some changes here to support different languages
            final Pattern PRODUCT_URL_PATTERN = Pattern.compile("@(Given|When|Then|And|But)\\(\"(.*)\"\\)");

            Matcher m = PRODUCT_URL_PATTERN.matcher(line);
            if (m.find()) {
                result = m.group(2);
            }

            return result;
        }

        public static String prepareStringForAppend(String fileAsString) {
            String result = fileAsString;

            int indexOfLastClosingCurlyBracket = fileAsString.lastIndexOf("\n}");

            if (indexOfLastClosingCurlyBracket > -1) {
                indexOfLastClosingCurlyBracket = fileAsString.lastIndexOf("}");
            }

            if (indexOfLastClosingCurlyBracket > -1) {
                result = fileAsString.substring(0, indexOfLastClosingCurlyBracket);
            }

            return result;
        }

        public static String addClosingCurlyBracket(String fileAsString) {
            return fileAsString.concat("}\n");
        }

    }

    private static final class FileToolBox {
        public static String readFile(String filePath) {
            String fileAsString = "";
            FileReader fr = null;
            BufferedReader br = null;
            try {
                fr = new FileReader(filePath);
                br = new BufferedReader(fr);

                while (br.ready()) {
                    fileAsString += br.readLine();
                    fileAsString += "\n";
                }

                // This close the enclosed FileReader as well
                br.close();
            }
            catch (Exception e) {
                System.out.println("ERROR OCCURED WHILE TRYING TO READ FILE: " + filePath);
                e.printStackTrace();
            }

            return fileAsString;
        }
    }

    private static void main(String[] args) {

        String featureFile = "/users/gregoire.duchemin/workspace/CucumberStepsWizard/src/integ/MyFeature.feature";
        String stepFile = "/users/gregoire.duchemin/workspace/CucumberStepsWizard/src/integ/steps/MyFeatureITSteps.java";

        String contextualStepFile = "/users/gregoire.duchemin/workspace/CucumberStepsWizard/src/integ/steps/ContextualITSteps.java";
        String genericStepsFile = "/users/gregoire.duchemin/workspace/CucumberStepsWizard/src/integ/steps/special/generic/GenericITSteps.java";
        String othersGenericStepsFile = "/users/gregoire.duchemin/workspace/CucumberStepsWizard/src/integ/steps/special/generic/OthersGenericITSteps.java";

        // System.out.println(addStepsFromFeatureFile(featureFile, stepFile, contextualStepFile, genericStepsFile, othersGenericStepsFile));

        for (String s : getMissingSteps(featureFile, stepFile, contextualStepFile, genericStepsFile, othersGenericStepsFile)) {
            System.out.println(s);
        }

    }
}
